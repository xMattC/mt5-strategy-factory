ðŸ’¡ Prompt:
Prompt for ChatGPT (YAML generator from MQL5 indicator code)

"I need you to generate a YAML configuration file from a given MQL5 indicator source code. The YAML file should:

Include the indicator name as the top-level key.

Include:

custom: true

indicator_path with the relative path "MyIndicators/{indicator_name}.ex5"

Extract all input variables from the code, including:

Their name

Default value

Data type (e.g. int, double, or enum types)

Min, max, step (if numeric)

And add optimize: true for numeric inputs; optimize: false for enums or text.

Extract all enum definitions (e.g. ENUM_MODE) with their members.

Extract all indicator buffers from SetIndexBuffer, listing their name and index.

Provide a base_conditions section with placeholders for long and short logic, initially empty or basic like:

long: ""

short: ""

Use YAML indentation and structure properly.

For example, from the following MQL5 indicator code snippet:

//+------------------------------------------------------------------+
//|                                                          ASO.mq5 |
//|                        Copyright 2018, MetaQuotes Software Corp. |
//|                                                 https://mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2018, MetaQuotes Software Corp."
#property link      "https://mql5.com"
#property version   "1.00"
#property description "Absolute Strength Oscillator"
#property indicator_separate_window
#property indicator_buffers 9
#property indicator_plots   2
//--- plot Bulls
#property indicator_label1  "Bulls strength"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrGreen
#property indicator_style1  STYLE_SOLID
#property indicator_width1  1
//--- plot Bears
#property indicator_label2  "Bears strength"
#property indicator_type2   DRAW_LINE
#property indicator_color2  clrRed
#property indicator_style2  STYLE_SOLID
#property indicator_width2  1
//--- enums
enum ENUM_MODE
  {
   MODE_RSI,   // RSI
   MODE_STO    // Stochastic
  };
//--- input parameters
input uint                 InpPeriod         =  9;             // Period
input uint                 InpPeriodSm       =  1;             // Smoothing
input ENUM_MODE            InpMode           =  MODE_RSI;      // Mode
input ENUM_MA_METHOD       InpMethod         =  MODE_SMA;      // Method
input ENUM_APPLIED_PRICE   InpAppliedPrice   =  PRICE_CLOSE;   // Applied price
//--- indicator buffers
double         BufferBulls[];
double         BufferBears[];
double         BufferBL[];
double         BufferBR[];
double         BufferAvgBL[];
double         BufferAvgBR[];
double         BufferAvgSmBL[];
double         BufferAvgSmBR[];
double         BufferMA[];
//--- global variables
int            period_ind;
int            period_sm;
int            period_max;
int            handle_ma;
int            weight_sum_bl;
int            weight_sum_br;
int            weight_sum_sbl;
int            weight_sum_sbr;
//--- includes
#include <MovingAverages.mqh>
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- set global variables
   period_ind=int(InpPeriod<1 ? 1 : InpPeriod);
   period_sm=int(InpPeriodSm<2 ? 2 : InpPeriodSm);
   period_max=fmax(period_ind,period_sm);
//--- indicator buffers mapping
   SetIndexBuffer(0,BufferBulls,INDICATOR_DATA);
   SetIndexBuffer(1,BufferBears,INDICATOR_DATA);
   SetIndexBuffer(2,BufferBL,INDICATOR_CALCULATIONS);
   SetIndexBuffer(3,BufferBR,INDICATOR_CALCULATIONS);
   SetIndexBuffer(4,BufferAvgBL,INDICATOR_CALCULATIONS);
   SetIndexBuffer(5,BufferAvgBR,INDICATOR_CALCULATIONS);
   SetIndexBuffer(6,BufferAvgSmBL,INDICATOR_CALCULATIONS);
   SetIndexBuffer(7,BufferAvgSmBR,INDICATOR_CALCULATIONS);
   SetIndexBuffer(8,BufferMA,INDICATOR_CALCULATIONS);
//--- setting indicator parameters
   string method=StringSubstr(EnumToString(InpMode),5);
   IndicatorSetString(INDICATOR_SHORTNAME,"ASO ("+(string)period_ind+","+(string)period_sm+")");
   IndicatorSetInteger(INDICATOR_DIGITS,Digits());
//--- setting buffer arrays as timeseries
   ArraySetAsSeries(BufferBulls,true);
   ArraySetAsSeries(BufferBears,true);
   ArraySetAsSeries(BufferBL,true);
   ArraySetAsSeries(BufferBR,true);
   ArraySetAsSeries(BufferAvgBL,true);
   ArraySetAsSeries(BufferAvgBR,true);
   ArraySetAsSeries(BufferAvgSmBL,true);
   ArraySetAsSeries(BufferAvgSmBR,true);
   ArraySetAsSeries(BufferMA,true);
//--- create MA's handles
   ResetLastError();
   handle_ma=iMA(NULL,PERIOD_CURRENT,1,0,MODE_SMA,InpAppliedPrice);
   if(handle_ma==INVALID_HANDLE)
     {
      Print("The iMA(1) object was not created: Error ",GetLastError());
      return INIT_FAILED;
     }
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
  {
//--- Ð£ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Ð¼Ð°ÑÑÐ¸Ð²Ð¾Ð² Ð±ÑƒÑ„ÐµÑ€Ð¾Ð² ÐºÐ°Ðº Ñ‚Ð°Ð¹Ð¼ÑÐµÑ€Ð¸Ð¹
   ArraySetAsSeries(high,true);
   ArraySetAsSeries(low,true);
//--- ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¸ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð° Ð¿Ñ€Ð¾ÑÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°ÐµÐ¼Ñ‹Ñ… Ð±Ð°Ñ€Ð¾Ð²
   if(rates_total<fmax(period_max,4) || Point()==0) return 0;
//--- ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¸ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð° Ð¿Ñ€Ð¾ÑÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°ÐµÐ¼Ñ‹Ñ… Ð±Ð°Ñ€Ð¾Ð²
   int limit=rates_total-prev_calculated;
   if(limit>1)
     {
      limit=rates_total-2;
      ArrayInitialize(BufferBulls,EMPTY_VALUE);
      ArrayInitialize(BufferBears,EMPTY_VALUE);
      ArrayInitialize(BufferBL,0);
      ArrayInitialize(BufferBR,0);
      ArrayInitialize(BufferAvgBL,0);
      ArrayInitialize(BufferAvgBR,0);
      ArrayInitialize(BufferAvgSmBL,0);
      ArrayInitialize(BufferAvgSmBR,0);
      ArrayInitialize(BufferMA,0);
     }
//--- ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ° Ð´Ð°Ð½Ð½Ñ‹Ñ…
   int bars=(limit>1 ? rates_total : 1),copied=0;
   copied=CopyBuffer(handle_ma,0,0,bars,BufferMA);
   if(copied!=bars) return 0;

   for(int i=limit; i>=0 && !IsStopped(); i--)
     {
      double Pr0=BufferMA[i];
      double Pr1=BufferMA[i+1];

      if(InpMode==MODE_RSI)
        {
         BufferBL[i]=0.5*fabs(Pr0-Pr1)+Pr0-Pr1;
         BufferBR[i]=0.5*fabs(Pr0-Pr1)-Pr0+Pr1;
        }
      else
        {
         int bh=Highest(period_ind,i);
         int bl=Lowest(period_ind,i);
         if(bh==WRONG_VALUE || bl==WRONG_VALUE)
            continue;
         double max=high[bh];
         double min=low[bl];
         BufferBL[i]=Pr0-min;
         BufferBR[i]=max-Pr0;
        }
     }
   switch(InpMethod)
     {
      case MODE_EMA  :
        if(ExponentialMAOnBuffer(rates_total,prev_calculated,0,period_ind,BufferBL,BufferAvgBL)==0) return 0;
        if(ExponentialMAOnBuffer(rates_total,prev_calculated,0,period_ind,BufferBR,BufferAvgBR)==0) return 0;
        break;
      case MODE_SMMA :
        if(SmoothedMAOnBuffer(rates_total,prev_calculated,0,period_ind,BufferBL,BufferAvgBL)==0) return 0;
        if(SmoothedMAOnBuffer(rates_total,prev_calculated,0,period_ind,BufferBR,BufferAvgBR)==0) return 0;
        break;
      case MODE_LWMA :
        if(LinearWeightedMAOnBuffer(rates_total,prev_calculated,0,period_ind,BufferBL,BufferAvgBL,weight_sum_bl)==0) return 0;
        if(LinearWeightedMAOnBuffer(rates_total,prev_calculated,0,period_ind,BufferBR,BufferAvgBR,weight_sum_br)==0) return 0;
        break;
      //---MODE_SMA
      default        :
        if(SimpleMAOnBuffer(rates_total,prev_calculated,0,period_ind,BufferBL,BufferAvgBL)==0) return 0;
        if(SimpleMAOnBuffer(rates_total,prev_calculated,0,period_ind,BufferBR,BufferAvgBR)==0) return 0;
        break;
     }
   switch(InpMethod)
     {
      case MODE_EMA  :
        if(ExponentialMAOnBuffer(rates_total,prev_calculated,period_ind,period_sm,BufferAvgBL,BufferAvgSmBL)==0) return 0;
        if(ExponentialMAOnBuffer(rates_total,prev_calculated,period_ind,period_sm,BufferAvgBR,BufferAvgSmBR)==0) return 0;
        break;
      case MODE_SMMA :
        if(SmoothedMAOnBuffer(rates_total,prev_calculated,period_ind,period_sm,BufferAvgBL,BufferAvgSmBL)==0) return 0;
        if(SmoothedMAOnBuffer(rates_total,prev_calculated,period_ind,period_sm,BufferAvgBR,BufferAvgSmBR)==0) return 0;
        break;
      case MODE_LWMA :
        if(LinearWeightedMAOnBuffer(rates_total,prev_calculated,period_ind,period_sm,BufferAvgBL,BufferAvgSmBL,weight_sum_sbl)==0) return 0;
        if(LinearWeightedMAOnBuffer(rates_total,prev_calculated,period_ind,period_sm,BufferAvgBR,BufferAvgSmBR,weight_sum_sbr)==0) return 0;
        break;
      //---MODE_SMA
      default        :
        if(SimpleMAOnBuffer(rates_total,prev_calculated,period_ind,period_sm,BufferAvgBL,BufferAvgSmBL)==0) return 0;
        if(SimpleMAOnBuffer(rates_total,prev_calculated,period_ind,period_sm,BufferAvgBR,BufferAvgSmBR)==0) return 0;
        break;
     }

//--- Ð Ð°ÑÑ‡Ñ‘Ñ‚ Ð¸Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð°
   for(int i=limit; i>=0 && !IsStopped(); i--)
     {
      BufferBulls[i]=BufferAvgSmBL[i]/Point();
      BufferBears[i]=BufferAvgSmBR[i]/Point();
     }

//--- return value of prev_calculated for next call
   return(rates_total);
  }
//+------------------------------------------------------------------+
//| Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð¸Ð½Ð´ÐµÐºÑ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ñ‚Ð°Ð¹Ð¼ÑÐµÑ€Ð¸Ð¸ High          |
//+------------------------------------------------------------------+
int Highest(const int count,const int start)
  {
   double array[];
   ArraySetAsSeries(array,true);
   return(CopyHigh(Symbol(),PERIOD_CURRENT,start,count,array)==count ? ArrayMaximum(array)+start : WRONG_VALUE);
  }
//+------------------------------------------------------------------+
//| Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð¸Ð½Ð´ÐµÐºÑ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ñ‚Ð°Ð¹Ð¼ÑÐµÑ€Ð¸Ð¸ Low            |
//+------------------------------------------------------------------+
int Lowest(const int count,const int start)
  {
   double array[];
   ArraySetAsSeries(array,true);
   return(CopyLow(Symbol(),PERIOD_CURRENT,start,count,array)==count ? ArrayMinimum(array)+start : WRONG_VALUE);
   return WRONG_VALUE;
  }
//+------------------------------------------------------------------+

would Generate:

ASO:
  custom: true
  indicator_path: "MyIndicators/ASO.ex5"

  inputs:
    InpPeriod:
      default: 9
      type: int
      min: 1
      max: 50
      step: 1
      optimize: true

    InpPeriodSm:
      default: 1
      type: int
      min: 1
      max: 10
      step: 1
      optimize: true

    InpMode:
      default: MODE_RSI
      type: ENUM_MODE
      optimize: false

    InpMethod:
      default: MODE_SMA
      type: ENUM_MA_METHOD
      optimize: false

    InpAppliedPrice:
      default: PRICE_CLOSE
      type: ENUM_APPLIED_PRICE
      optimize: false

  enums:
    ENUM_MODE:
      - MODE_RSI
      - MODE_MACD

  buffers:
    - name: Bulls
      index: 0
    - name: Bears
      index: 1

  base_conditions:
    long: "Bulls[0] > Bears[0] && Bulls[1] < Bears[1]"
    short: "Bulls[0] < Bears[0] && Bulls[1] > Bears[1]"

do you understand can i pase in the new indicator to be processed?